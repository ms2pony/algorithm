# note

## 无重复字符的最长子串

问题描述：给定一个字符串`s`，请你找出其中不含有重复字符的**最长子串**的长度
参考：<https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/>

## 两数之和-链表

问题描述：给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
参考：<https://leetcode-cn.com/problems/add-two-numbers/>

### 链表增长实现的代码

```cpp
p->next = new ListNode(l1->val + carry);
p = p->next;

// p = p->next;
// p->next = new ListNode(l1->val + carry);
```

分析上面的代码：这两行的顺序决不能颠倒，注释的两行就是颠倒了，颠倒后无法增长链表

## 三数之和

给你一个包含`n`个整数的数组`nums`，判断`nums`中是否存在三个元素 $a,b,c$，使得 $a+b+c=0$?请你找出所有和为`0`且不重复的三元组。
**注意**：答案中不可以包含重复的三元组
参考：<https://leetcode-cn.com/problems/3sum/>

### 实现

时间复杂度降至 $O(N^{2})$ 的办法，排序+双指针的方法：

1. 保证没有重复三元组(关于排序)：
   - 保证枚举的三元组 $(a,b,c)$满足 $a\leq b \leq c$，能够减少重复
   - 对数组排序
   - 一个循环的遍历不能遍历两个值相同的元素
2. 使用双指针将复杂度降低到 $O(N^{2})$
   可以发现，如果我们固定了前两重循环的元素$a$和$b$，那么只有唯一的 $c$ 满足 $a+b+c=0$。当第二重循环往后枚举一个元素 $b'$时，由于 $b'>b$，那么满足 $a+b'+c'$的 $c'$ 一定有 $c'<c$，即 $c'$ 在数组中一定出现在 $c$ 的左侧。也就是说我们可以从小到大枚举 $b$，**同时** 从大到小枚举 $c$，即第二重循环和第三重循环实际上是并列的。

## 子数组范围和问题

给你一个整数数组`nums`。`nums`中，子数组的**范围**是子数组中最大元素和最小元素的差值。返回`nums`中**所有**子数组范围的**和**

参考：<https://leetcode-cn.com/problems/sum-of-subarray-ranges/>
参考：<https://leetcode-cn.com/problems/sum-of-subarray-ranges/solution/zi-shu-zu-fan-wei-he-by-leetcode-solutio-lamr/>

### 遍历子数组的方法

通过合理的方法来枚举可以减少时间复杂度，根据数组左右边界确定数组的方法来枚举是一个合理的枚举方法，
该算法过程如下：

1. 枚举数组

   先枚举子数组的左边界$i$，然后枚举子数组右边界$j$，且 $i \leq j$，
   note：在枚举每个$i$时都要枚举所有的$j$。

2. 确定每次访问的子数组的范围

   对于相同左边界$i$而言，每次确定右边界$j$后都能够在 O(1)下确定子数组的最小值 $minVal$ 与最大值 $maxVal$，从而算出范围$maxVal-minVal$，
   因为某次枚举的子数组是在上一次子数组的基础上加了一个元素。这都归功于步骤 1 合理的枚举方法
