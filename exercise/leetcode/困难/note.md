# 困难

## 二分查找-找中位数

问题描述：给定两个大小分别为`m`和`n`的正序(从小到大)数组`nums1`和`nums2`。请你找出并返回这个正序数组的**中位数**。算法的时间复杂度应该为`O(log(m+n))`
参考：<https://leetcode-cn.com/problems/median-of-two-sorted-arrays/>

### 实现方法

中间切法和固定左边数切法，都是通过不断迭代筛选出小于中位数的数得到中位数，区别是每次迭代时的筛选是否都从两个数组的中间判断。

#### 中间切法

1. 筛选`nums1`和`nums2`中在中位数左边的数，并剔除他们，做法：一直往中间切
2. 最后一步，比较剩下的`nums1`和`nums2`的最小的两个数的大小，谁最小谁就是中位数
3. 另外，由于`m+n`的奇偶性，需要要分情况讨论

实现：参考 [中间切法实现](二分查找-找中位数.cpp) k(函数 findMedianSortedArrays1 和 findMedianSortedArrays2，前者进行了改进和优化)

不足和缺点：对于找出中位数这个问题来说是个不完备的解决方法，

1. 因为有时会存在其中一个数组的较小数永远无法被筛掉的情况：
   如`nums1=[0,0,0,0,0]，nums2=[-1,0,0,0,0,0,1]`，对于`nums1`和`nums2`来说，只需要筛选出 5 个小于中位数的数即可找到中位数，
   但是由于中位数左边的数与中位数以及中位数右边的数相等，导致筛选的时候 nums1 数组的元素会一直被删除，
   所以 nums2 的元素个数永远不会减少，所以切的位置一直是`nums2[4]=0`，`nums1`被删完后，已经筛选出 5 个
   "好像是"在中位数左边的 5 个数，但是 nums2 中的`-1`并没有被删去
2. 筛选过程中会超过中位数左边的数的数量，例子`[1, 3, 10, 11], [-1, 2, 4, 9]`

总结：
中间切法的缺点如下：

1. 切割位置固定的弊端
   归根结底是因为中间切法切的位置有时是固定不变的，这样就会导致其中一个数组较小的元素不能被及时被剔除，这种弊端在面对
   `nums1`和`nums2`合并后是`[-1,0,0,0,0,0,1]`的这种情况束手无策，因为不止 3 个小于等于中位数。
2. 筛选过程会超过期望值

#### 固定左边数切法

能够解决中间切法的两个确定，并具有完备性(对于找出中位数这个问题)

0. 取 k 为中位数及中位数左边元素的个数(包含中位数)
1. 筛选`nums1`和`nums2`中在中位数左边的数，并剔除他们，做法：每次筛选时从最左侧开始数，到`k/2`的时候切，一轮筛选后 k 会更新
2. 最后一步，比较剩下的`nums1`和`nums2`的最小的两个数的大小，谁最小谁就是中位数
3. 另外，由于`m+n`的奇偶性，需要要分情况讨论

note：对于找出中位数这个问题来说为什么固定左边数切法是完备的，而中间切法却不是完备的，我只能简单解释：
因为中间切法每次筛选时切的位置总是变化的，而中间切法并不总是会变化。
