## 排序算法

### 选择排序

（有序区，无序区），双循环，找到最小的就与无序区第一个元素交换，用到 swap 函数；数组不稳定，链表稳定，O(n2)

### 冒泡排序

（无序区，有序区），有序区在后面逐渐生成，双循环，内部循环遍历无序区每个元素，每个元素与后面元素比较，后者小则交换；改进算法，若内部 for 遍历一遍后没有一次交换则跳出整个循环(外循环)；稳定，O(n2)

### 插入排序

（有序区，无序区），双循环，遍历无序区，将遍历的元素插入到有序区合适的位置，插入的位置选择：从后到前遍历有序区，如果有序区当前元素更小，就插在这个元素后面，否则继续遍历。没有用 swap 函数，所以找合适位置这个过程比较复杂：在遍历到有序区的元素更小前，每次遍历都需要交换位置，关键代码为：

```c++
//内循环中的关键代码
v[j + 1] = v[j]; //j+1的初始值为i，也就是temp的初始位置，所以不用担心这行代码会覆盖其他元素
v[j] = temp; //无序区第一个元素，即待插入元素
```

完毕。稳定，O(n2)

### 快速排序

（小数，基准元素，大数），选一个数作为基准，将小于基准的数放在基准前，大的放在基准后，实现方法有：递归，模板，迭代。使用的代码有两层嵌套 while 循环，并且条件有重复，内层 while 两个循环中的等于条件随便落在哪个循环的条件中

- 递归：重点，主要是确定基准位置这个过程

- 模板：与递归类似，但确定基准位置这个过程的代码实现有些许不同，确定基准位置代码和讲解如下：

```c++
while (left < right) {
   while (arr[left] < mid && left < right)
   left++;
   while (arr[right] >= mid && left < right)
   right--;
   std::swap(arr[left], arr[right]);
}
//边界后的处理
if (arr[left] >= arr[end])
        std::swap(arr[left], arr[end]);
else
    left++; //这为什么和上面交换，这是难点
```

line12，如果要交换的话也只要一行代码：`std::swap(arr[left++], arr[end])`。但是你如果仔细观察就会发现`arr[left++]`实际上就是`arr[end]`，理由如下：

内层的两个 while 中的第一个是`while (arr[left] < mid && left < right)`，这说明是先检查左边的元素，所以当整个外层循环结束后，left 虽然等于 right，但还是能确定`arr[left] < mid`或`arr[right] < mid`，除非发生`arr[left++]`就是`arr[end]`这种情况，示意图：

![image-20220402171558018](img\image-20220402171558018.png)

`std::swap(arr[left++], arr[end])`换成`left++`其实就是简化了一下代码，性能好像没有明显的提升。下面给出整个确定基准位置的示意图：

![image-20220402172740465](img\image-20220402172740465.png)

- 迭代：比较难理解，定义了一个 range 的数据结构和一个堆栈，但他其实是模板版本的变体
  总结：不稳定，O(n\*log2n)，最差 O(n2)，不稳定，<mark>空间复杂度为 O(log2n)(递归实现的情况下)，其他实现的方式并不一定是 O(log2n)</mark>，关于空间复杂的参考：<https://zhuanlan.zhihu.com/p/123416868> k 根据实现方式的不同而不同

### 堆排序

不稳定，最差和平均都为 O(n\*log2n)

- 前置概念：完全二叉树：倒数第一层和倒数第二层才有叶子节点，且叶子都集中在左边

- 完全二叉树与顺序存储的映射公式：设一个完全二叉树的节点个数为 len，则下标为 i 的节点的左孩子为 2i+1，右孩子为 2i+2；最后一个非叶子节点(也可以叫父节点)为`len/2-1`；

  参考：<https://www.cnblogs.com/chengxiao/p/6129630.html> k 叶结点自然不用调整

- 大根堆和小根堆：大根堆是每个节点的值都小于或等于左右孩子节点的值，对应顺序存储中的规则为：`arr[i]>=arr[2i+i]&&arr[i] >= arr[2i+2]`。小根堆相反：`arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]`

- <mark>堆的向下调整操作思路和代码讲解</mark>：

  参考：<https://www.cnblogs.com/lylhome/p/13276081.html> k 堆排序分为两步，即初始化堆、调整堆

  1. 如果父亲节点大于两个孩子节点(或一个孩子节点)，则调整完成
  2. 如果不满足 1 中说的条件，则将父节点和较大孩子节点交换
  3. 将原来较大的孩子结点作为父亲结点，重复上述两步的操作，直到孩子结点是叶子结点为止

  上述描述用代码实现可以用一个 while 循环，代码如下：

  ```c++
  while (son <= end) { //当前节点为父节点(非叶子节点)
    if (son + 1 <= end && arr[son] < arr[son + 1]) //找出最大的孩子
     son++;
    if (arr[dad] > arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數
     return;
    else { //否則交換父子內容再繼續子節點和孫節點比較
     swap(arr[dad], arr[son]);
     dad = son;
     son = dad * 2 + 1; //左孩子，左孩子一定存在，右孩子不一定
    }
   }
  ```

- 堆的初始化和向下调整的关系：初始化堆的时间复杂度为 O(n)，向下调整为 O(logn)，因为初始化堆由若干向下调整操作组成

  - 向下调整操作：操作对象为一个节点，堆排序在初始化堆后，后续的向下调整操作的节点都是根节点，该操作的示意图如下：

    ![image-20220403103904512](img\image-20220403103904512.png)

    意思就是说，根节点的左子树和右子树都是大根堆了，唯独根节点对应的树不是，这个时候大根堆的调整只要对根节点执行向下调整即可

  - 堆的初始化：操作对象为一个大根堆的所有父节点(非叶子节点)，操作是向下调整操作

- 堆初始化和向下调整操作时间复杂度分析

  参考：<https://www.cnblogs.com/lylhome/p/13276081.html> k 初始化堆的时间复杂度分析 (讲得很好)

### 归并排序

空间复杂度为：O(n)，参考：<https://zhuanlan.zhihu.com/p/124356219> k 归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间 (空间复杂度的分析)

- prerequirement
  两个已经有序的是如何合并的

- code 写法

  1. while 是 for 和 if 语句的结合
     while 循环相当于 if 语句中加个 for 循环，如果平时需要判断一个条件是否成立再循环，并且不用给初始条件，且每次迭代一边后的处理也不用体现在 for 循环中，
     那么就可以使用 while 循环，下面就是个例子：

     ```c++
     while (start1 < end1)
        b[k++] = a[start1++];
     //上面两行代码等价于下面
     for(int i=0;start1<end1;i++)
        b[k+i] = a[start1+i];
     ```

  2. 使用双指针遍历有序序列注意的点

     ```c++
     //不是<=，则序列不包含end指向的元素
     while (start < end)
       b[k++]=a[start++] //将一个序列的元素传给另一个序列

     //是<=，则序列包含end指向的元素
     while (start <= end)
       b[k++]=a[start++] //将一个序列的元素传给另一个序列
     ```

- 递归和迭代的代码实现的区别
  在这里，递归和迭代的代码实现可以看做彼此的逆过程

- 核心代码

  ```c++
  //迭代版
  while (start1 <= end1 && start2 <= end2)
    reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
  while (start1 <= end1)
    reg[k++] = arr[start1++];
  while (start2 <= end2)
    reg[k++] = arr[start2++];
  //合并到reg后，reg是合并后的一系列更大的有序序列，将reg中的元素复制到arr中
  for (k = start; k <= end; k++)
    arr[k] = reg[k];
  ```

- 基本思想

  - 简化

    1. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含 4 个元素
    2. 将上述序列再次归并，形成 floor(n/2)个序列，每个序列包含 4 个元素
    3. 重复步骤 2，直到所有元素排序完毕

  - 详细
    1. 申请空间，该空间用来存放合并后的序列
    2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
    3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间中，并移动指针到下一位置
    4. 重复步骤 3 直到某一指针达到序列尾部
    5. 将另一序列剩下的所有元素直接复制到合并序列尾部
    6. 选择另外两个序列，重复步骤 2 到 5，直到没有序列可以合并
    7. 将合并空间的序列中的序列作为新的已经排序序列，重复步骤 2 到 6，直到执行完步骤 6 后，合并空间只有一个序列
